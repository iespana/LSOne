using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace LSOne.DataLayer.SqlDataProviders.ItemMaster
{
    public class AssemblyItemQueries
    {
        /// <summary>
        /// Query to calculate the total cost of all components in an assembly
        /// Does not handle assembly in assembly
        /// </summary>
        public static string AssemblyTotalCostQuery = @"CASE WHEN CC.COSTCALCULATION = 2 THEN -- Get manual cost price
        ISNULL((SELECT SUM(R.PURCHASEPRICE * COALESCE(UNIT1.FACTOR, 1 / UNIT1R.FACTOR, UNIT2.FACTOR, 1 / UNIT2R.FACTOR, 1) * C.QUANTITY) AS COST FROM RETAILITEMASSEMBLYCOMPONENTS C 
                                                 INNER JOIN RETAILITEM R ON C.ITEMID = R.ITEMID 
                                                 LEFT JOIN UNITCONVERT UNIT1 ON UNIT1.FROMUNIT = R.SALESUNITID AND UNIT1.TOUNIT = C.UNITID AND UNIT1.ITEMID = C.ITEMID
												 LEFT JOIN UNITCONVERT UNIT1R ON UNIT1R.TOUNIT = R.SALESUNITID AND UNIT1R.FROMUNIT = C.UNITID AND UNIT1R.ITEMID = C.ITEMID
                                                 LEFT JOIN UNITCONVERT UNIT2 ON UNIT2.FROMUNIT = R.SALESUNITID AND UNIT2.TOUNIT = C.UNITID AND UNIT2.ITEMID = ''
										         LEFT JOIN UNITCONVERT UNIT2R ON UNIT2R.TOUNIT = R.SALESUNITID AND UNIT2R.FROMUNIT = C.UNITID AND UNIT2R.ITEMID = ''
                                                 WHERE C.ASSEMBLYID = A.ID), 0)
        ELSE
        CASE WHEN A.STOREID <> '' THEN -- Get calculate cost price when we have a specific store
        ISNULL((SELECT SUM(ISNULL(RIC.CALCULATEDCOSTPRICE, 0) * COALESCE(UNIT1.FACTOR, 1 / UNIT1R.FACTOR, UNIT2.FACTOR, 1 / UNIT2R.FACTOR, 1) * C.QUANTITY) AS COST FROM RETAILITEMASSEMBLYCOMPONENTS C 
            INNER JOIN RETAILITEM R ON C.ITEMID = R.ITEMID 
			OUTER APPLY (SELECT TOP 1 COST AS CALCULATEDCOSTPRICE, UNITID AS COSTUNITID FROM RETAILITEMCOST RIC WHERE RIC.ITEMID = R.ITEMID AND RIC.STOREID = A.STOREID ORDER BY ENTRYDATE DESC) RIC
            LEFT JOIN UNITCONVERT UNIT1 ON UNIT1.FROMUNIT = RIC.COSTUNITID AND UNIT1.TOUNIT = C.UNITID AND UNIT1.ITEMID = C.ITEMID
			LEFT JOIN UNITCONVERT UNIT1R ON UNIT1R.TOUNIT = RIC.COSTUNITID AND UNIT1R.FROMUNIT = C.UNITID AND UNIT1R.ITEMID = C.ITEMID
            LEFT JOIN UNITCONVERT UNIT2 ON UNIT2.FROMUNIT = RIC.COSTUNITID AND UNIT2.TOUNIT = C.UNITID AND UNIT2.ITEMID = ''
			LEFT JOIN UNITCONVERT UNIT2R ON UNIT2R.TOUNIT = RIC.COSTUNITID AND UNIT2R.FROMUNIT = C.UNITID AND UNIT2R.ITEMID = ''
            WHERE C.ASSEMBLYID = A.ID), 0)
        ELSE -- Get weighted average cost price for all stores
        ISNULL((SELECT SUM(ISNULL(RIC.CALCULATEDCOSTPRICE, 0) * COALESCE(UNIT1.FACTOR, 1 / UNIT1R.FACTOR, UNIT2.FACTOR, 1 / UNIT2R.FACTOR, 1) * C.QUANTITY) AS COST FROM RETAILITEMASSEMBLYCOMPONENTS C 
            INNER JOIN RETAILITEM R ON C.ITEMID = R.ITEMID 
			OUTER APPLY (SELECT ITEMID, MAX(UNITID) AS COSTUNITID, IIF(SUM(QUANTITY) > 0, SUM(COST) / SUM(QUANTITY), 0) AS CALCULATEDCOSTPRICE FROM (
						SELECT TOP 1 WITH TIES IC.ITEMID, IC.COST * IIF(ISNULL(V.QUANTITY, 0) < 0, 0, ISNULL(V.QUANTITY, 0)) AS COST, IC.UNITID, IIF(ISNULL(V.QUANTITY, 0) < 0, 0, ISNULL(V.QUANTITY, 0)) AS QUANTITY 
						FROM RETAILITEMCOST IC 
						LEFT JOIN VINVENTSUM V ON V.ITEMID = IC.ITEMID AND V.STOREID = IC.STOREID
						WHERE IC.ITEMID = R.ITEMID
						ORDER BY ROW_NUMBER() OVER (PARTITION BY IC.STOREID ORDER BY IC.ENTRYDATE DESC)) X
						GROUP BY X.ITEMID) RIC
            LEFT JOIN UNITCONVERT UNIT1 ON UNIT1.FROMUNIT = RIC.COSTUNITID AND UNIT1.TOUNIT = C.UNITID AND UNIT1.ITEMID = C.ITEMID
			LEFT JOIN UNITCONVERT UNIT1R ON UNIT1R.TOUNIT = RIC.COSTUNITID AND UNIT1R.FROMUNIT = C.UNITID AND UNIT1R.ITEMID = C.ITEMID
            LEFT JOIN UNITCONVERT UNIT2 ON UNIT2.FROMUNIT = RIC.COSTUNITID AND UNIT2.TOUNIT = C.UNITID AND UNIT2.ITEMID = ''
			LEFT JOIN UNITCONVERT UNIT2R ON UNIT2R.TOUNIT = RIC.COSTUNITID AND UNIT2R.FROMUNIT = C.UNITID AND UNIT2R.ITEMID = ''
            WHERE C.ASSEMBLYID = A.ID), 0) END 
	    END";

        /// <summary>
        /// Query to get the cost of a component
        /// </summary>
        public static string AssemblyComponentCostQuery = @"CASE WHEN CC.COSTCALCULATION = 2 THEN -- Get manual cost price
        ISNULL((SELECT R.PURCHASEPRICE * COALESCE(UNIT1.FACTOR, 1 / UNIT1R.FACTOR, UNIT2.FACTOR, 1 / UNIT2R.FACTOR, 1) FROM RETAILITEM R
		LEFT JOIN UNITCONVERT UNIT1 ON UNIT1.FROMUNIT = R.SALESUNITID AND UNIT1.TOUNIT = AC.UNITID AND UNIT1.ITEMID = AC.ITEMID
		LEFT JOIN UNITCONVERT UNIT1R ON UNIT1R.TOUNIT = R.SALESUNITID AND UNIT1R.FROMUNIT = AC.UNITID AND UNIT1R.ITEMID = AC.ITEMID
		LEFT JOIN UNITCONVERT UNIT2 ON UNIT2.FROMUNIT = R.SALESUNITID AND UNIT2.TOUNIT = AC.UNITID AND UNIT2.ITEMID = ''
		LEFT JOIN UNITCONVERT UNIT2R ON UNIT2R.TOUNIT = R.SALESUNITID AND UNIT2R.FROMUNIT = AC.UNITID AND UNIT2R.ITEMID = ''
		WHERE R.ITEMID = AC.ITEMID), 0)
        ELSE
        CASE WHEN A.STOREID <> '' THEN -- Get calculate cost price when we have a specific store
        ISNULL((SELECT RIC.CALCULATEDCOSTPRICE * COALESCE(UNIT1.FACTOR, 1 / UNIT1R.FACTOR, UNIT2.FACTOR, 1 / UNIT2R.FACTOR, 1) FROM RETAILITEM R
			OUTER APPLY (SELECT TOP 1 COST AS CALCULATEDCOSTPRICE, UNITID AS COSTUNITID FROM RETAILITEMCOST RIC WHERE RIC.ITEMID = R.ITEMID AND RIC.STOREID = A.STOREID ORDER BY ENTRYDATE DESC) RIC
            LEFT JOIN UNITCONVERT UNIT1 ON UNIT1.FROMUNIT = RIC.COSTUNITID AND UNIT1.TOUNIT = AC.UNITID AND UNIT1.ITEMID = AC.ITEMID
			LEFT JOIN UNITCONVERT UNIT1R ON UNIT1R.TOUNIT = RIC.COSTUNITID AND UNIT1R.FROMUNIT = AC.UNITID AND UNIT1R.ITEMID = AC.ITEMID
            LEFT JOIN UNITCONVERT UNIT2 ON UNIT2.FROMUNIT = RIC.COSTUNITID AND UNIT2.TOUNIT = AC.UNITID AND UNIT2.ITEMID = ''
			LEFT JOIN UNITCONVERT UNIT2R ON UNIT2R.TOUNIT = RIC.COSTUNITID AND UNIT2R.FROMUNIT = AC.UNITID AND UNIT2R.ITEMID = ''
            WHERE R.ITEMID = AC.ITEMID), 0)
        ELSE -- Get weighted average cost price for all stores
        ISNULL((SELECT RIC.CALCULATEDCOSTPRICE * COALESCE(UNIT1.FACTOR, 1 / UNIT1R.FACTOR, UNIT2.FACTOR, 1 / UNIT2R.FACTOR, 1) FROM RETAILITEM R
			OUTER APPLY (SELECT ITEMID, MAX(UNITID) AS COSTUNITID, IIF(SUM(QUANTITY) > 0, SUM(COST) / SUM(QUANTITY), 0) AS CALCULATEDCOSTPRICE FROM (
						SELECT TOP 1 WITH TIES IC.ITEMID, IC.COST * IIF(ISNULL(V.QUANTITY, 0) < 0, 0, ISNULL(V.QUANTITY, 0)) AS COST, IC.UNITID, IIF(ISNULL(V.QUANTITY, 0) < 0, 0, ISNULL(V.QUANTITY, 0)) AS QUANTITY 
						FROM RETAILITEMCOST IC 
						LEFT JOIN VINVENTSUM V ON V.ITEMID = IC.ITEMID AND V.STOREID = IC.STOREID
						WHERE IC.ITEMID = R.ITEMID
						ORDER BY ROW_NUMBER() OVER (PARTITION BY IC.STOREID ORDER BY IC.ENTRYDATE DESC)) X
						GROUP BY X.ITEMID) RIC
            LEFT JOIN UNITCONVERT UNIT1 ON UNIT1.FROMUNIT = RIC.COSTUNITID AND UNIT1.TOUNIT = AC.UNITID AND UNIT1.ITEMID = AC.ITEMID
			LEFT JOIN UNITCONVERT UNIT1R ON UNIT1R.TOUNIT = RIC.COSTUNITID AND UNIT1R.FROMUNIT = AC.UNITID AND UNIT1R.ITEMID = AC.ITEMID
            LEFT JOIN UNITCONVERT UNIT2 ON UNIT2.FROMUNIT = RIC.COSTUNITID AND UNIT2.TOUNIT = AC.UNITID AND UNIT2.ITEMID = ''
			LEFT JOIN UNITCONVERT UNIT2R ON UNIT2R.TOUNIT = RIC.COSTUNITID AND UNIT2R.FROMUNIT = AC.UNITID AND UNIT2R.ITEMID = ''
            WHERE R.ITEMID = AC.ITEMID), 0) END 
	    END";

        /// <summary>
        /// Query to calculate the total sales price of all components in an assembly where the assembly is marked to calculate price from components
        /// Uses recursion to calculate assembly items as components
        /// </summary>
        public static string AssemblyTotalSalesPriceQuery = @";WITH COMPS AS(
        SELECT   
        AC.ITEMID,
        AC.QUANTITY,
        AC.UNITID,
        R.SALESUNITID,
        A.ID AS ASSEMBLYID,
        A.STOREID,
        CASE WHEN R.ITEMTYPE = 4 THEN 1 ELSE 0 END AS PARENTASSEMBLY,
        CASE WHEN ISNULL(A1.ID, A2.ID) IS NULL THEN R.SALESPRICEINCLTAX ELSE CASE WHEN ISNULL(A1.CALCULATEPRICEFROMCOMPS, A2.CALCULATEPRICEFROMCOMPS) = 1 THEN 0 ELSE ISNULL(A1.PRICE, A2.PRICE) END END AS SALESPRICE,
        ISNULL(A1.ID, A2.ID) AS PARENTASSEMBLYID,
        ISNULL(A1.CALCULATEPRICEFROMCOMPS, A2.CALCULATEPRICEFROMCOMPS) AS CALCULATEPRICEFROMCOMPS,
        ISNULL(A1.PRICE, A2.PRICE) AS PRICE
        FROM RETAILITEMASSEMBLYCOMPONENTS AC
        INNER JOIN RETAILITEMASSEMBLY A ON A.ID = AC.ASSEMBLYID
        INNER JOIN RETAILITEM R ON AC.ITEMID = R.ITEMID
        OUTER APPLY (SELECT * FROM (SELECT RA.ID, RA.CALCULATEPRICEFROMCOMPS, RA.PRICE, ROW_NUMBER() OVER (PARTITION BY ID ORDER BY STARTINGDATE DESC) AS RN FROM RETAILITEMASSEMBLY RA WHERE RA.ITEMID = AC.ITEMID AND ENABLED = 1 AND RA.STOREID = A.STOREID AND CAST(A.STARTINGDATE AS DATE) <= CAST(GETDATE() AS DATE)) AS A1 WHERE A1.RN = 1) AS A1
        OUTER APPLY (SELECT * FROM (SELECT RA.ID, RA.CALCULATEPRICEFROMCOMPS, RA.PRICE, ROW_NUMBER() OVER (PARTITION BY ID ORDER BY STARTINGDATE DESC) AS RN FROM RETAILITEMASSEMBLY RA WHERE RA.ITEMID = AC.ITEMID AND ENABLED = 1 AND RA.STOREID = '' AND CAST(A.STARTINGDATE AS DATE) <= CAST(GETDATE() AS DATE)) AS A2 WHERE A2.RN = 1) AS A2
        WHERE A.ITEMID = @ITEMID
        UNION ALL
        SELECT
        AC.ITEMID,
        AC.QUANTITY,
        AC.UNITID,
        R.SALESUNITID,
        C.ASSEMBLYID,
        C.STOREID,
        CASE WHEN R.ITEMTYPE = 4 THEN 1 ELSE 0 END AS PARENTASSEMBLY,
        CASE WHEN ISNULL(A1.ID, A2.ID) IS NULL THEN R.SALESPRICEINCLTAX ELSE CASE WHEN ISNULL(A1.CALCULATEPRICEFROMCOMPS, A2.CALCULATEPRICEFROMCOMPS) = 1 THEN 0 ELSE ISNULL(A1.PRICE, A2.PRICE) END END AS SALESPRICE,
        ISNULL(A1.ID, A2.ID) AS PARENTASSEMBLYID,
        ISNULL(A1.CALCULATEPRICEFROMCOMPS, A2.CALCULATEPRICEFROMCOMPS) AS CALCULATEPRICEFROMCOMPS,
        ISNULL(A1.PRICE, A2.PRICE) AS PRICE
        FROM RETAILITEMASSEMBLYCOMPONENTS AC
        INNER JOIN RETAILITEMASSEMBLY A ON A.ID = AC.ASSEMBLYID
        INNER JOIN RETAILITEM R ON AC.ITEMID = R.ITEMID
        INNER JOIN COMPS C ON A.ITEMID = C.ITEMID AND C.PARENTASSEMBLY = 1 AND C.CALCULATEPRICEFROMCOMPS = 1
        OUTER APPLY (SELECT * FROM (SELECT RA.ID, RA.CALCULATEPRICEFROMCOMPS, RA.PRICE, ROW_NUMBER() OVER (PARTITION BY ID ORDER BY STARTINGDATE DESC) AS RN FROM RETAILITEMASSEMBLY RA WHERE RA.ITEMID = AC.ITEMID AND ENABLED = 1 AND RA.STOREID = A.STOREID AND CAST(A.STARTINGDATE AS DATE) <= CAST(GETDATE() AS DATE)) AS A1 WHERE A1.RN = 1) AS A1
        OUTER APPLY (SELECT * FROM (SELECT RA.ID, RA.CALCULATEPRICEFROMCOMPS, RA.PRICE, ROW_NUMBER() OVER (PARTITION BY ID ORDER BY STARTINGDATE DESC) AS RN FROM RETAILITEMASSEMBLY RA WHERE RA.ITEMID = AC.ITEMID AND ENABLED = 1 AND RA.STOREID = '' AND CAST(A.STARTINGDATE AS DATE) <= CAST(GETDATE() AS DATE)) AS A2 WHERE A2.RN = 1) AS A2
        )";

        /// <summary>
        /// Query to check if a new item that would be added to an assembly would cause a circular reference
        /// Uses recursion to check in both direction, up the chain of assemblies and down the chain
        /// Does not check archived assemblies
        /// </summary>
        public static string AssemblyCircularReferenceQuery = @"-- Find items going up the chain
        ;WITH UP AS(
        SELECT
        A.ITEMID,
        A.ID AS ASSEMBLYID
        FROM RETAILITEMASSEMBLYCOMPONENTS C
        INNER JOIN RETAILITEMASSEMBLY A ON A.ID = C.ASSEMBLYID
        WHERE C.ITEMID = @ITEMID
        UNION ALL
        SELECT
        A.ITEMID,
        A.ID AS ASSEMBLYID
        FROM RETAILITEMASSEMBLYCOMPONENTS AC
        INNER JOIN UP U ON U.ITEMID = AC.ITEMID
        INNER JOIN RETAILITEMASSEMBLY A ON A.ID = AC.ASSEMBLYID
        ) -- Find items going down the chain
        ,DOWN AS(
        SELECT
        C.ITEMID,
        @ASSEMBLYID AS ASSEMBLYID
        FROM RETAILITEMASSEMBLYCOMPONENTS C
        INNER JOIN RETAILITEM I ON I.ITEMID = C.ITEMID
        WHERE C.ASSEMBLYID = @ASSEMBLYID AND I.ITEMTYPE = 4

        UNION ALL
        SELECT
        AC.ITEMID,
        A.ID AS ASSEMBLYID
        FROM RETAILITEM R
        INNER JOIN DOWN D ON D.ITEMID = R.ITEMID
        INNER JOIN RETAILITEMASSEMBLY A ON A.ITEMID = D.ITEMID
        INNER JOIN RETAILITEMASSEMBLYCOMPONENTS AC ON AC.ASSEMBLYID = A.ID
        INNER JOIN RETAILITEM R2 ON R2.ITEMID = AC.ITEMID
        WHERE R2.ITEMTYPE = 4
        ), -- Combine the results
        RESULTS AS(
        SELECT ITEMID, ASSEMBLYID FROM UP
        UNION ALL
        SELECT ITEMID, ASSEMBLYID FROM DOWN
        UNION ALL
        SELECT @ITEMID, @ASSEMBLYID AS ITEMID
        ) -- Filter out archived assemblies and check if the item exists
        SELECT CASE WHEN EXISTS (
        SELECT ITEMID FROM(
        SELECT DISTINCT R.ITEMID FROM RESULTS R
        INNER JOIN RETAILITEMASSEMBLY A ON R.ASSEMBLYID = A.ID
        WHERE CAST(A.STARTINGDATE AS DATE) > CAST(GETDATE() AS DATE)
        UNION ALL
        SELECT DISTINCT R.ITEMID FROM RESULTS R
        INNER JOIN RETAILITEMASSEMBLY A ON R.ASSEMBLYID = A.ID
        WHERE CAST(A.STARTINGDATE AS DATE) <= GETDATE() AND (ENABLED = 0 OR A.ID = (SELECT TOP 1 ID FROM RETAILITEMASSEMBLY RC WHERE ENABLED = 1 AND CAST(A.STARTINGDATE AS DATE) <= GETDATE() AND ITEMID = A.ITEMID AND STOREID = A.STOREID ORDER BY STARTINGDATE DESC))
        ) A WHERE A.ITEMID = @ITEMIDTOCHECK)
        THEN CAST(1 AS BIT) ELSE CAST(0 AS BIT) END AS RESULT";

        /// <summary>
        /// Query to calculate inventory for assembly items
        /// Uses recursion to calculate assembly items as components
        /// Inventory result is considered the inventory value of the item with the lowest available sales based on inventory available and quantity sold for each sale
        /// </summary>
        public static string AssemblyInventoryQuery = @";WITH COMPS AS(
        Select   
            -- Columns
        IT.ITEMID,
        IT.ITEMNAME,
        IT.VARIANTNAME,
        IT.INVENTORYUNITID,
        RST.STOREID,
        RST.NAME AS STORENAME,
        ISNULL(A1.ID, A2.ID) AS ASSEMBLYID,
        AC.ITEMID AS COMPONENTITEMID,
        CASE WHEN ITC.ITEMTYPE = 4 THEN 1 ELSE 0 END AS PARENTASSEMBLY,
        CASE WHEN ITC.ITEMTYPE = 3 THEN 1 ELSE 0 END AS HEADERITEM
        FROM RETAILITEM IT 
        -- Joins
        CROSS JOIN RBOSTORETABLE RST
        OUTER APPLY (SELECT TOP 1 A.ID, A.DESCRIPTION FROM RETAILITEMASSEMBLY A WHERE A.ITEMID = @ITEMID AND ENABLED = 1 AND A.STOREID = RST.STOREID AND CAST(A.STARTINGDATE AS DATE) <= CAST(GETDATE() AS DATE) ORDER BY STARTINGDATE DESC) AS A1
        OUTER APPLY (SELECT TOP 1 A.ID, A.DESCRIPTION FROM RETAILITEMASSEMBLY A WHERE A.ITEMID = @ITEMID AND ENABLED = 1 AND A.STOREID = '' AND CAST(A.STARTINGDATE AS DATE) <= CAST(GETDATE() AS DATE) ORDER BY STARTINGDATE DESC) AS A2
        INNER JOIN RETAILITEMASSEMBLYCOMPONENTS AC ON ISNULL(A1.ID, A2.ID) = AC.ASSEMBLYID
        INNER JOIN RETAILITEM ITC ON AC.ITEMID = ITC.ITEMID
        WHERE IT.ITEMID = @ITEMID AND ITC.ITEMTYPE <> 2 #1

        UNION ALL
        SELECT
        IT.ITEMID,
        IT.ITEMNAME,
        IT.VARIANTNAME,
        IT.INVENTORYUNITID,
        RST.STOREID,
        RST.NAME AS STORENAME,
        ISNULL(A1.ID, A2.ID) AS ASSEMBLYID,
        AC.ITEMID AS COMPONENTITEMID,
        CASE WHEN ITC.ITEMTYPE = 4 THEN 1 ELSE 0 END AS PARENTASSEMBLY,
        CASE WHEN ITC.ITEMTYPE = 3 THEN 1 ELSE 0 END AS HEADERITEM
        FROM RETAILITEM IT 
        -- Joins
        INNER JOIN (SELECT C.COMPONENTITEMID, ROW_NUMBER() OVER (PARTITION BY C.COMPONENTITEMID ORDER BY C.COMPONENTITEMID ASC) AS RN FROM COMPS C WHERE C.PARENTASSEMBLY = 1) AS C ON RN = 1 AND IT.ITEMID = C.COMPONENTITEMID
        CROSS JOIN RBOSTORETABLE RST
        OUTER APPLY (SELECT * FROM (SELECT A.ID, A.DESCRIPTION, ROW_NUMBER() OVER (PARTITION BY ID ORDER BY STARTINGDATE DESC) AS RN FROM RETAILITEMASSEMBLY A WHERE A.ITEMID = IT.ITEMID AND ENABLED = 1 AND A.STOREID = RST.STOREID AND CAST(A.STARTINGDATE AS DATE) <= CAST(GETDATE() AS DATE)) AS A1 WHERE A1.RN = 1) AS A1
        OUTER APPLY (SELECT * FROM (SELECT A.ID, A.DESCRIPTION, ROW_NUMBER() OVER (PARTITION BY ID ORDER BY STARTINGDATE DESC) AS RN FROM RETAILITEMASSEMBLY A WHERE A.ITEMID = IT.ITEMID AND ENABLED = 1 AND A.STOREID = '' AND CAST(A.STARTINGDATE AS DATE) <= CAST(GETDATE() AS DATE)) AS A2 WHERE A2.RN = 1) AS A2
        INNER JOIN RETAILITEMASSEMBLYCOMPONENTS AC ON ISNULL(A1.ID, A2.ID) = AC.ASSEMBLYID
        INNER JOIN RETAILITEM ITC ON AC.ITEMID = ITC.ITEMID
        WHERE ITC.ITEMTYPE <> 2 #1
        )
        SELECT DISTINCT
        C.ITEMID,
        C.ITEMNAME,
        C.VARIANTNAME ,
        C.STOREID ,
        C.STORENAME,
        C.INVENTORYUNITID,
        C.COMPONENTITEMID,
        CAST(C.HEADERITEM AS BIT) AS HEADERITEM,
        ISNULL(INS.INVENTORYQUANTITY, 0) AS INVENTORYQUANTITY,
        ISNULL(INS.COMPONENTQUANTITY, 0) AS COMPONENTQUANTITY,
        ISNULL(U.MINUNITDECIMALS,0) AS MINUNITDECIMALS,
        ISNULL(U.UNITDECIMALS,0) AS MAXUNITDECIMALS,
        ISNULL(U.UNITID,'') AS UNITID,
        ISNULL(U.TXT,'') AS UNITTEXT
        FROM COMPS C 
        OUTER APPLY (SELECT I.QUANTITY AS INVENTORYQUANTITY, AC.QUANTITY * COALESCE(1 / CONV.FACTOR, RCONV.FACTOR, 1 / CONVGLOB.FACTOR, RCONVGLOB.FACTOR, 1) AS COMPONENTQUANTITY
                                    FROM VINVENTSUM I
                                    LEFT JOIN RETAILITEMASSEMBLYCOMPONENTS AC ON AC.ASSEMBLYID = C.ASSEMBLYID AND AC.ITEMID = I.ITEMID
                                    LEFT JOIN RETAILITEM IT ON IT.ITEMID = AC.ITEMID
                                    LEFT JOIN UNITCONVERT CONV ON CONV.FROMUNIT = AC.UNITID AND CONV.TOUNIT = IT.INVENTORYUNITID AND CONV.ITEMID = AC.ITEMID
                                    LEFT JOIN UNITCONVERT RCONV ON RCONV.TOUNIT = AC.UNITID AND RCONV.FROMUNIT = IT.INVENTORYUNITID AND RCONV.ITEMID = AC.ITEMID
                                    LEFT JOIN UNITCONVERT CONVGLOB ON CONVGLOB.FROMUNIT = AC.UNITID AND CONVGLOB.TOUNIT = IT.INVENTORYUNITID AND CONVGLOB.ITEMID = ''
                                    LEFT JOIN UNITCONVERT RCONVGLOB ON RCONVGLOB.TOUNIT = AC.UNITID AND RCONVGLOB.FROMUNIT = IT.INVENTORYUNITID AND RCONVGLOB.ITEMID = ''
                                    WHERE  I.STOREID = C.STOREID AND IT.ITEMTYPE <> 4 AND I.ITEMID = C.COMPONENTITEMID
                                    ) AS INS
        LEFT OUTER JOIN UNIT U ON  C.INVENTORYUNITID = U.UNITID 
        WHERE PARENTASSEMBLY = 0";
    }
}
